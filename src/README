tomer_zilb, idomi
326063047, 215334251

Explanation regarding how we chose to implement the trees package:
1. The different classes we chose to define:

2. The relations between the classes:

3. The design patterns we chose to utilize:


Explanation regarding how we chose to implement the Cloud functionality:
1. The different classes we chose to define:
We decided to implement:
 - Cloud: A general class to represent a single cloud.
 - CloudAction: A FunctionalInterface interface to essentially allow a lambda function
 to be passed to the Cloud class.
 - RainDrop: A class to represent a single drop of rain, mainly just a standalone GameObject
 - RainDropAction: A FunctionalInterface interface to have the RainDrop do a GameManager action
 when it collides with other objects.
 - AvatarJumpListener: An interface that the Cloud class implements so that it can get notified
 (called) whenever the Avatar jumps
2. The relations between the classes:
 - Cloud implements AvatarJumpListener so that it would get notified upon jumps.
 - CloudAction is held as a property of Cloud so that Cloud objects can call lambda functions given
 from GameManager that access gameObjects() while blackboxing it to the Cloud itself. We stand
 by this decision as the things done are the GameManager's duty and not the Cloud's
 - RainDrop holds RainDropAction as a property for the same reasons as CloudAction.
3. The design patterns we chose to utilize:
 - Observer pattern: used in Cloud with AvatarJumpListener.
 - Command/Lambda/Strategy pattern: used in CloudAction and RainDropAction.
 - Encapsulation: used in all main classes (PepseGameManager, Cloud, RainDrop)

Explanation regarding how we chose to implement the game in general:

In general, we attempted to fix the design problems from exercise 2 so that the general principles
still stood, but no passing of gameObjects() or the gameManager instance would go around - mainly
lambdas are passed around. This means that the control of the behavior is as we see it should be,
upon the game's manager. We've thought about splitting the lambdas into only "removeGameObject()",
but that essentially brings us right back to exercise 2's solution - so we thought that it'd be
best to keep the functionality that we think fits best.